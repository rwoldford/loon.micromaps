
#' Micromaps in loon
#'
#' @export
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr arrange_ select_ mutate
#' @importFrom purrr walk
#'
#' @examples
#' \dontrun{
#'
#' library(micromap)
#'
#' data("USstates")
#' data("edPov")
#'
#' USstates@data <- merge(USstates@data, edPov, by.x = 'ST', by.y = 'StateAb')
#'
#' mm <- l_micromaps(spdf = USstates,
#'                   lab.label = 'States',
#'                   variables = list(id.var = 'ST_NAME',
#'                                    grouping.var = list(name = 'pov', xlab = 'Percent'),
#'                                    var2 = list(name = 'ed', xlab = 'Percent')),
#'                   linkingGroup = 'micromaps', sync = 'push')
#'
#' }
#'
l_micromaps <- function(tt = tktoplevel(), var_inspector = TRUE,
                        spdf, grouping = NULL, n_groups = NULL,
                        map.label = 'Map', lab.label = 'Labels', title = 'Micromaps',
                        variables = list(id.var = NULL, ...),
                        color = NULL, size = 6,
                        linkingKey = NULL, linkingGroup = NULL, sync = c('pull', 'push'), ...) {

  .Tcl('set ::loon::Options(printInConfigurationWarning) FALSE')

  # Input checks -----
  if (!is(tt, 'tkwin'))
    stop('tt should be a Tk toplevel window generated by tktoplevel()')

  if (!is.logical(var_inspector) | length(var_inspector) > 1)
    stop('var_inspector should be TRUE or FALSE only')

  if (!is(spdf, 'SpatialPolygonsDataFrame'))
    stop('spdf must be of class SpatialPolygonsDataFrame')

  if (length(unique(spdf@plotOrder)) != nrow(spdf@data)) {
    stop('plotOrder for spdf does not correspond to the number of data points')
  }

  for (vars in c('map.label', 'lab.label', 'title')) {
    if (!is.character(get(vars)) | length(get(vars)) > 1 | identical(get(vars), ''))
      stop(paste0(vars, ' must be a single non-empty string'))
  }

  if (!(sync %in% c('push', 'pull'))) {
    stop('sync for linking states must be either pull or push')
  }



  if (!is.list(variables)) stop('variables should be specified as a nested list.')


  if (!('id.var' %in% names(variables))) stop('Must specify the name of the id.var in variables as list(id.var = ...)')

  id.var <- variables$id.var
  if (!(id.var %in% names(spdf@data))) stop('id.var does not exist in spdf data')


  if (!('grouping.var' %in% names(variables))) {
    stop('Must specify the grouping.var in variables as list(grouping.var = list(name = ...))')
  }

  # Assign grouping and other variables (including type checks)
  vars <- Map(function(x, y) {
    variable_check(spdf, x, y)
  }, setdiff(names(variables), 'id.var'), variables[-which(names(variables) == 'id.var')])


  for (x in names(vars)) {

    assign(x, vars[[x]]$name)
    assign(paste0(x, '.xlab'), vars[[x]]$xlab)
    assign(paste0(x, '.label'), vars[[x]]$label)

  }

  scatterplot_vars <- names(vars)



  # Data-related -----
  n <- nrow(spdf@data)
  spdf@data$id <- 1:n
  spdf@data$NAME <- as.character(spdf@data[[id.var]])

  grouping <- allocate_group(n_groups = n_groups, grouping = grouping, n = n)
  n_groups <- length(grouping)

  group <- Map(function(x, y) {
    rep(y, times = x)
  }, grouping, 1:n_groups) %>% unlist()


  color_orig <- color
  if (!is.null(color) & !is.character(color)) stop('color, if specified, should consist of character values')

  if (is.null(color)) color <- loon_palette(max(grouping))
  if (length(color) > 0) color <- rep(color, length.out = max(grouping))


  if (is.null(linkingKey)) linkingKey <- as.character(spdf@data$NAME)
  spdf@data$linkingKey <- linkingKey

  if (is.null(linkingGroup)) linkingGroup <- 'Micromaps'


  spdf@data <- spdf@data %>%
    arrange_(.dots = c(paste0('-', grouping.var), 'NAME')) %>%
    mutate(group = group) %>%
    arrange(id)


  plotorder_exp <- Map(function(x) {

    n <- length(spdf@polygons[[x]]@Polygons)
    rep(x, times = n)

  }, spdf@plotOrder) %>% unlist()


  xlims <- lapply(scatterplot_vars, function(v) {
    spdf@data[[get(v)]] %>% extendrange()
  })



  # Set up loon
  # tt <- tktoplevel()
  tktitle(tt) <- title

  p_scatterplot <- lapply(1:length(scatterplot_vars), function(v) {
    vector(length = n_groups)
  })

  p_map_base <- vector(length = n_groups)
  p_map <- vector('list', length = n_groups)

  p_label <- vector(length = n_groups)
  p_label_text <- vector(length = n_groups)


  p_scale_base <- vector(length = n_groups)
  p_scale_labs <- vector(length = n_groups)
  p_scale_ticks <- vector(length = n_groups)


  color_df <- vector('list', length = n_groups)

  mapping_scatterplot2map <- vector('list', length = n_groups)
  mapping_map2scatterplot <- vector('list', length = n_groups)



  # Create plots -----
  for (i in 1:n_groups) {

    data <- spdf@data[spdf@data$group == i, ] %>%
      arrange_(.dots = c(paste0('-', grouping.var), 'NAME'))

    data$colors <- color[1:nrow(data)]


    # Scatterplot(s)
    for (jj in 1:length(scatterplot_vars)) {

      var <- get(scatterplot_vars[jj])

      p_scatterplot[[jj]][i] <- l_plot(parent = tt,
                                       x = data[[var]],
                                       y = seq(grouping[i], 1),
                                       color = color[1:nrow(data)],
                                       size = size,
                                       linkingKey = data$linkingKey,
                                       linkingGroup = linkingGroup,
                                       sync = sync, ...)

      l_configure(p_scatterplot[[jj]][i],
                  panX = xlims[[jj]][1], zoomX = 1, deltaX = diff(xlims[[jj]]),
                  panY = 0, zoomY = 1, deltaY = grouping[i] + 1,
                  showLabels = T, xlabel = '', ylabel = '')

    }



    # Maps
    p_map_base[i] <- l_plot(parent = tt)

    p_map[[i]] <- l_layer(p_map_base[i], spdf,
                          color = 'cornsilk',
                          asSingleLayer = TRUE, label = paste0('map_', i))

    l_scaleto_world(p_map_base[i])


    # Get colors for polygons
    color_df[[i]] <- data.frame(key = plotorder_exp,
                                color = data$colors[match(plotorder_exp, data$id)],
                                stringsAsFactors = F)
    color_df[[i]]$color[is.na(color_df[[i]]$color)] <- 'cornsilk'

    l_configure(c(p_map_base[i], p_map[[i]]), color = color_df[[i]]$color)



    # Labels
    p_label[i] <- l_plot(parent = tt,
                         x = rep(1, nrow(data)),
                         y = seq(grouping[i], 1),
                         color = color[1:nrow(data)],
                         size = size,
                         linkingKey = data$linkingKey,
                         linkingGroup = linkingGroup,
                         sync = sync, ...)

    l_configure(p_label[i], panX = 0, zoomX = 1, deltaX = 6,
                panY = 0, zoomY = 1, deltaY = grouping[i] + 1,
                xlabel = '', ylabel = '')


    # Truncate label text if they are too long
    trunc_labels <- vapply(as.character(data$NAME),
                           function(x) ifelse(nchar(x) > 25, paste0(substr(x, 1, 25), '...'), x),
                           FUN.VALUE = character(1), USE.NAMES = F)

    p_label_text[i] <- l_layer_texts(p_label[i],
                                     x = rep(2, nrow(data)),
                                     y = seq(grouping[i], 1),
                                     text = trunc_labels,
                                     anchor = 'w',
                                     size = size,
                                     col = 'black')


    mapping_scatterplot2map[[i]] <- lapply(data$NAME, function(x) which(attr(p_map[[i]], 'NAME') == x))
    names(mapping_scatterplot2map[[i]]) <- data$NAME

    mapping_map2scatterplot[[i]] <- match(attr(p_map[[i]], 'NAME'), data$NAME)

  }


  pr_transform <- function(x, pan, zoom, delta) {
    (x - pan)/(zoom * delta)
  }

  pr_invtransform <- function(y, pan, zoom, delta) {
    y * zoom * delta + pan
  }


  # Axis for scatterplots -----
  axis_tickpoints <- lapply(scatterplot_vars, function(v) pretty(spdf@data[[get(v)]], n = 5))


  for (kk in 1:length(scatterplot_vars)) {

    axis <- axis_tickpoints[[kk]]

    p_scale_base[kk] <- l_plot(parent = tt,
                               background = 'gray95', foreground = 'gray95',
                               showLabels = T, xlabel = '', ylabel = '',
                               minimumMargins = c(0, 20, 0, 20), showScales = F)

    p_scale_labs[kk] <- l_layer_texts(p_scale_base[kk],
                                      x = axis, y = rep(0.3, length(axis)),
                                      text = axis, color = 'black')

    p_scale_ticks[kk] <- l_layer_lines(p_scale_base[kk],
                                       x = list(c(min(xlims[[kk]], axis), max(xlims[[kk]], axis)),
                                                c(axis[2], axis[2]),
                                                c(axis[3], axis[3]),
                                                c(axis[4], axis[4]),
                                                c(axis[5], axis[5])),
                                       y = list(c(0.7, 0.7),
                                                c(0.5, 0.7),
                                                c(0.5, 0.7),
                                                c(0.5, 0.7),
                                                c(0.5, 0.7)))

    l_configure(p_scale_base[kk],
                panX = xlims[[kk]][1], zoomX = 1, deltaX = diff(xlims[[kk]]))

  }



  # Bindings -----

  # Zoom/pan/delta of scatterplots
  b_xmoves <- lapply(1:length(scatterplot_vars), function(v) {
    do.call('bind_zoompandelta', c(direction = 'x', as.list(c(p_scatterplot[[v]], p_scale_base[v]))))
  })


  b_ymoves <- lapply(1:n_groups, function(v) {

    scatterplots <- lapply(1:length(scatterplot_vars), function(z) p_scatterplot[[z]][v])

    do.call('bind_zoompandelta', c(direction = 'y', c(p_label[v], scatterplots)))

  })


  # Connecting scatterplot points to polygons in maps
  b_scatterplot2map <- lapply(1:n_groups, function(x) {
    bind_scat2map(s = p_scatterplot[[1]][x], m = p_map[[x]],
                  mapping = mapping_scatterplot2map[[x]], orig_colors = color_df[[x]]$color)
  })


  b_map2scatterplot <- lapply(1:n_groups, function(x) {
    bind_map2scat(s = p_scatterplot[[1]][x], m = p_map[[x]], m_base = p_map_base[x],
                  mapping = mapping_map2scatterplot[[x]])
  })


  b_map2scat_add <- lapply(1:n_groups, function(x) {
    bind_map2scat_add(s = p_scatterplot[[1]][x], m = p_map[[x]], m_base = p_map_base[x],
                      mapping = mapping_map2scatterplot[[x]])
  })


  # Prevent zoom/pan in the horizontal direction for the label (leftmost) column
  b_disable <- lapply(1:n_groups, function(x) {
    disable_zoompandelta(direction = 'x', p_label[x])
  })



  # Packing -----

  # Reset grid configuration; otherwise going from 2 -> 1 scatterplot columns will still leave 4 columns overall
  old <- as.character(tkgrid.slaves(tt))
  walk(old, function(x) tkgrid.forget(x))


  # Create labels
  label_lab <- tcl('label', l_subwin(tt,'label_for_labels'), text = lab.label)

  stat_labs <- lapply(1:length(scatterplot_vars), function(v) {
    var <- scatterplot_vars[v]
    tcl('label', l_subwin(tt, paste0('label_for_scat_', v)), text = get(paste0(var, '.label')))
  })

  axis_labs <- lapply(1:length(scatterplot_vars), function(v) {
    var <- scatterplot_vars[v]
    tcl('label', l_subwin(tt, paste0('axis_label_for_', v)), text = get(paste0(var, '.xlab')))
  })

  map_lab <- tcl('label', l_subwin(tt,'label_for_maps'), text = map.label)


  # Layout
  n_row <- n_groups + 3
  n_col <- length(scatterplot_vars) + 2


  tkgrid(label_lab, row = 0, column = 0, sticky = "nesw")

  for (ii in 1:length(scatterplot_vars)) {
    tkgrid(stat_labs[[ii]], row = 0, column = ii, sticky = 'nesw')
  }

  tkgrid(map_lab, row = 0, column = n_col - 1, sticky = "nesw")


  for (ii in 1:n_groups) {

    tkgrid(p_label[ii], row = ii, column = 0, sticky = 'nesw')

    for (jj in 1:length(scatterplot_vars)) {
      tkgrid(p_scatterplot[[jj]][ii], row = ii, column = jj, sticky = 'nesw')
    }

    tkgrid(p_map_base[ii], row = ii, column = n_col - 1, sticky = 'nesw')

  }


  for (jj in 1:length(scatterplot_vars)) {

    tkgrid(p_scale_base[jj], row = n_groups + 1, column = jj, sticky = 'nesw')
    tkgrid(axis_labs[[jj]], row = n_row - 1, column = jj, sticky = 'nesw')

  }



  for (c in 0:(n_col - 1)) {
    tkgrid.columnconfigure(tt, c, weight = 2)
  }


  for (r in 1:(n_row - 2)) {
    tkgrid.rowconfigure(tt, r, weight = 2)
  }
  tkgrid.rowconfigure(tt, n_groups + 1, weight = 3, minsize = 20)




  # Inspector -----
  mmInspector <- function(w) {

    tt_inspector <- tktoplevel()
    tktitle(tt_inspector) <- 'Micromaps Custom Inspector'

    overall <- tkframe(tt_inspector)
    gr <- tkframe(overall, relief = 'groove', borderwidth = 3)
    sz <- tkframe(overall, borderwidth = 3)
    opt <- tkframe(overall, relief = 'groove', borderwidth = 3)
    final <- tkframe(overall, borderwidth = 3)


    # Grouping section
    vars <- setdiff(names(spdf@data)[sapply(spdf@data, is.numeric)],
                    c('id', 'name', 'NAME', 'group', 'linkingKey'))


    grouping.var_i <- tclVar(grouping.var)
    box.grouping.var <- ttkcombobox(gr, values = vars,
                                    textvariable = grouping.var_i,
                                    state = 'readonly')
    grouping.var.xlab_i <- tclVar(grouping.var.xlab)
    entry.grouping.var.xlab <- tkentry(gr, textvariable = grouping.var.xlab_i, width = 20)
    grouping.var.label_i <- tclVar(grouping.var.label)
    entry.grouping.var.label <- tkentry(gr, textvariable = grouping.var.label_i, width = 20)


    n_groups_i <- tclVar(ifelse(is.null(n_groups), '', as.character(n_groups)))
    entry.n_groups <- tkentry(gr, textvariable = n_groups_i, width = 20)

    grouping_char <- paste0(grouping, collapse = ',')
    grouping_i <- tclVar(ifelse(is.null(grouping), '', grouping_char))
    entry.grouping <- tkentry(gr, textvariable = grouping_i, width = 20)


    tkgrid(tklabel(gr, text = 'Grouping', anchor = 'e'),
           padx = 5, pady = 5, row = 0, columnspan = 4, sticky = 'w')

    tkgrid(tklabel(gr, text = 'Grouping variable: ', anchor = 'w'),
           tklabel(gr, text = 'Axis label: ', anchor = 'w'),
           tklabel(gr, text = 'Plot label: ', anchor = 'w'),
           sticky = 'w', padx = 5, pady = 5, row = 1)

    tkgrid(box.grouping.var,
           entry.grouping.var.xlab,
           entry.grouping.var.label,
           sticky = 'w', padx = 5, pady = 5, row = 2)

    tkgrid(tklabel(gr, text = 'Number of groups: ', anchor = 'w'),
           tklabel(gr, text = 'Grouping: ', anchor = 'w'),
           sticky = 'w', padx = 5, pady = 5, row = 3)

    tkgrid(entry.n_groups, entry.grouping,
           sticky = 'w', padx = 5, pady = 5, row = 4)



    currSize <- tclVar(as.character(size))
    size_disp <- tklabel(sz, textvariable = currSize)

    minus <- tkbutton(sz, text = '-', command = function() downsize())
    plus <- tkbutton(sz, text = '+', command = function() upsize())


    tkgrid(tklabel(sz, text = 'Fontsize: ', anchor = 'w'),
           minus, plus, size_disp)



    var2_i <- tclVar(ifelse(exists('var2'), var2, 'NA'))
    box.var2 <- ttkcombobox(opt, values = c('NA', vars),
                            textvariable = var2_i,
                            state = 'readonly')
    var2.xlab_i <- tclVar(ifelse(exists('var2.xlab'), var2.xlab, ''))
    entry.var2.xlab <- tkentry(opt, textvariable = var2.xlab_i, width = 20)
    var2.label_i <- tclVar(ifelse(exists('var2.label'), var2.label, ''))
    entry.var2.label <- tkentry(opt, textvariable = var2.label_i, width = 20)


    tkgrid(tklabel(opt, text = 'Optional', anchor = 'e'),
           padx = 5, pady = 5, row = 0, columnspan = 4, sticky = 'w')

    tkgrid(tklabel(opt, text = 'Optional variable: ', anchor = 'w'),
           tklabel(opt, text = 'Axis label: ', anchor = 'w'),
           tklabel(opt, text = 'Plot label: ', anchor = 'w'),
           sticky = 'w', padx = 5, pady = 5, row = 1)

    tkgrid(box.var2,
           entry.var2.xlab,
           entry.var2.label,
           sticky = 'w', padx = 5, pady = 5, row = 2)



    submit <- tkbutton(final, text = 'Submit', command = function() updatemm())

    tkgrid(submit, sticky = 'nse', padx = 5, pady = 5)


    tkgrid(gr, sticky = 'w')
    tkgrid(sz, sticky = 'w')
    tkgrid(opt, sticky = 'w')
    tkgrid(final, sticky = 'e')
    tkgrid(overall)



    upsize <- function() {

      newsize <- as.numeric(tclvalue(currSize)) + 1
      tclvalue(currSize) <- as.character(newsize)


      lapply(p_label, function(pp) l_configure(pp, size = newsize))
      lapply(1:length(p_label_text), function(ii) l_configure(c(p_label[ii], p_label_text[ii]), size = newsize))

      lapply(p_scatterplot, function(ll) {

        lapply(ll, function(pp) l_configure(pp, size = newsize))

      })

    }

    downsize <- function() {

      s <- as.numeric(tclvalue(currSize))

      if (s == 1) {
        newsize <- 1
      } else {
        newsize <- s - 1
      }

      tclvalue(currSize) <- as.character(newsize)


      lapply(p_label, function(pp) l_configure(pp, size = newsize))
      lapply(1:length(p_label_text), function(ii) l_configure(c(p_label[ii], p_label_text[ii]), size = newsize))

      lapply(p_scatterplot, function(ll) {

        lapply(ll, function(pp) l_configure(pp, size = newsize))

      })

    }



    updatemm <- function() {


      grouping.var_new <- tclvalue(grouping.var_i)
      grouping.var.xlab_new <- tclvalue(grouping.var.xlab_i)
      grouping.var.label_new <- tclvalue(grouping.var.label_i)

      var2_new <- tclvalue(var2_i)
      var2.xlab_new <- tclvalue(var2.xlab_i)
      var2.label_new <- tclvalue(var2.label_i)


      if (identical(tclvalue(grouping_i), '')) {
        grouping_new <- NULL
      } else {
        grouping_new <- tclvalue(grouping_i) %>%
          strsplit(., ',') %>% unlist() %>%
          trimws() %>% as.numeric()
      }

      if (identical(tclvalue(n_groups_i), '')) {
        n_groups_new <- NULL
      } else {
        n_groups_new <- as.numeric(tclvalue(n_groups_i))
      }


      size_new <- as.numeric(tclvalue(currSize))


      if (identical(var2_new, 'NA')) {
        variables = list(id.var = id.var,
                         grouping.var = list(name = grouping.var_new,
                                             xlab = grouping.var.xlab_new,
                                             label = grouping.var.label_new))
      } else {
        variables = list(id.var = id.var,
                         grouping.var = list(name = grouping.var_new,
                                             xlab = grouping.var.xlab_new,
                                             label = grouping.var.label_new),
                         var2 = list(name = var2_new,
                                     xlab = var2.xlab_new,
                                     label = var2.label_new))
      }


      spdf@data <- spdf@data[, !(names(spdf@data) %in% c('linkingKey', 'group'))]


      l_micromaps(tt = w$top, var_inspector = FALSE,
                  spdf = spdf, grouping = grouping_new, n_groups = n_groups_new,
                  variables = variables,
                  map.label = map.label, lab.label = lab.label, title = title,
                  color = color_orig, size = size_new,
                  linkingKey = linkingKey, linkingGroup = linkingGroup, sync = sync, ...)


    }

    tt_inspector

  }

  if (var_inspector) mmInspector(ret)



  # Return values -----
  ret <- list(top = tt,
              linkingGroup = linkingGroup,
              linkingKey = linkingKey,
              labels = list(base = p_label, text = p_label_text),
              scatterplots = p_scatterplot,
              maps = list(base = p_map_base, polygons = p_map))

  return(invisible(ret))

}

